"""
Structured schema for analysis plans generated by PlannerAgent
"""
from typing import List, Dict, Any, Optional, Literal
from pydantic import BaseModel, Field, validator
from datetime import datetime


class DataRequirements(BaseModel):
    """Data requirements specification"""
    datasets: List[str] = Field(min_items=1, description="Required datasets")
    time_windows: Dict[str, str] = Field(description="Time window specifications")
    filters: List[str] = Field(default=[], description="Required data filters")

    @validator("datasets")
    def validate_dataset_names(cls, v):
        """Validate dataset names are reasonable"""
        valid_datasets = ["rx_claims", "med_claims", "provider_payments", "providers_bio"]
        for dataset in v:
            if not any(valid_name in dataset.lower() for valid_name in valid_datasets):
                raise ValueError(f"Unknown dataset type: {dataset}")
        return v


class FeatureEngineering(BaseModel):
    """Feature engineering specification"""
    feature_types: List[Literal["volume", "growth", "consistency", "behavioral"]] = Field(
        min_items=1, description="Types of features to generate"
    )
    custom_features: List[str] = Field(default=[], description="Custom feature specifications")

    @validator("feature_types")
    def validate_feature_types(cls, v):
        """Ensure at least volume features are included for predictive modeling"""
        if "predictive" in str(v) and "volume" not in v:
            raise ValueError("Volume features are required for predictive modeling")
        return v


class AnalysisStep(BaseModel):
    """Individual analysis step"""
    step: int = Field(ge=1, description="Step number in sequence")
    action: str = Field(min_length=5, description="Action to be taken")
    description: str = Field(min_length=10, description="Detailed description of step")
    tools: List[str] = Field(min_items=1, description="Required tools for this step")
    outputs: List[str] = Field(min_items=1, description="Expected outputs")
    dependencies: List[int] = Field(default=[], description="Steps this depends on")
    estimated_duration: Optional[str] = Field(None, description="Estimated execution time")

    @validator("tools")
    def validate_tools(cls, v):
        """Validate tool names are known"""
        known_tools = [
            "text_to_sql_rx", "text_to_sql_med", "text_to_sql_provider_payments",
            "text_to_sql_providers_bio", "bigquery_sql_query", "feature_engineering",
            "trajectory_classification", "predictive_analysis", "web_search",
            "clinical_context_search", "communicate", "complete"
        ]

        for tool in v:
            if tool not in known_tools:
                raise ValueError(f"Unknown tool: {tool}")
        return v


class SuccessCriteria(BaseModel):
    """Success criteria definition"""
    criterion: str = Field(min_length=10, description="Success criterion")
    metric: Optional[str] = Field(None, description="Measurable metric if applicable")
    threshold: Optional[float] = Field(None, description="Threshold value for success")


class AnalysisPlanSchema(BaseModel):
    """Complete analysis plan schema"""

    # Metadata
    created_at: datetime = Field(default_factory=datetime.now, description="Plan creation timestamp")
    planner_version: str = Field(default="v3.0", description="Planner agent version")

    # Core plan components
    query_type: Literal["predictive_analysis", "descriptive_analysis", "exploratory"] = Field(
        description="Type of analysis requested"
    )
    objective: str = Field(min_length=20, description="Clear statement of analysis objective")

    data_requirements: DataRequirements = Field(description="Data needs specification")
    feature_engineering: FeatureEngineering = Field(description="Feature engineering requirements")
    analysis_steps: List[AnalysisStep] = Field(min_items=1, description="Sequential analysis steps")
    success_criteria: List[SuccessCriteria] = Field(min_items=1, description="Success criteria")
    expected_outputs: List[str] = Field(min_items=1, description="Expected deliverables")

    # Optional components
    assumptions: List[str] = Field(default=[], description="Key assumptions made")
    risks: List[str] = Field(default=[], description="Potential risks and mitigation")
    estimated_complexity: Literal["low", "medium", "high"] = Field(
        default="medium", description="Estimated complexity level"
    )

    class Config:
        """Pydantic configuration"""
        validate_assignment = True
        extra = "forbid"
        schema_extra = {
            "example": {
                "query_type": "predictive_analysis",
                "objective": "Identify early prescribing characteristics that predict high prescribers at Month 12",
                "data_requirements": {
                    "datasets": ["rx_claims"],
                    "time_windows": {"early_period": "1-3 months", "target_period": "12 months"},
                    "filters": ["active_prescribers", "sufficient_data_quality"]
                },
                "feature_engineering": {
                    "feature_types": ["volume", "growth", "consistency"],
                    "custom_features": ["month_over_month_acceleration"]
                },
                "analysis_steps": [
                    {
                        "step": 1,
                        "action": "data_extraction",
                        "description": "Extract prescribing data for Months 1-3 and Month 12",
                        "tools": ["text_to_sql_rx", "bigquery_sql_query"],
                        "outputs": ["prescribing_dataset"]
                    }
                ],
                "success_criteria": [
                    {
                        "criterion": "Achieve prediction accuracy > 75%",
                        "metric": "accuracy_score",
                        "threshold": 0.75
                    }
                ]
            }
        }

    @validator("analysis_steps")
    def validate_step_sequence(cls, v):
        """Validate steps are properly sequenced"""
        step_numbers = [step.step for step in v]
        expected_sequence = list(range(1, len(v) + 1))

        if step_numbers != expected_sequence:
            raise ValueError("Steps must be numbered sequentially starting from 1")

        # Validate dependencies
        for step in v:
            for dep in step.dependencies:
                if dep >= step.step:
                    raise ValueError(f"Step {step.step} cannot depend on step {dep} (circular or forward dependency)")
                if dep not in step_numbers:
                    raise ValueError(f"Step {step.step} depends on non-existent step {dep}")

        return v

    @validator("query_type", pre=True)
    def validate_query_type_alignment(cls, v, values):
        """Ensure query type aligns with objective"""
        if "objective" in values:
            objective = values["objective"].lower()
            if v == "predictive_analysis" and "predict" not in objective:
                raise ValueError("Predictive analysis should have 'predict' in objective")
        return v

    def validate_plan_completeness(self) -> List[str]:
        """Validate plan completeness and coherence"""
        issues = []

        # Check if predictive analysis has appropriate steps
        if self.query_type == "predictive_analysis":
            step_actions = [step.action for step in self.analysis_steps]

            required_actions = ["data_extraction", "feature_engineering"]
            for required in required_actions:
                if not any(required in action for action in step_actions):
                    issues.append(f"Predictive analysis missing required action: {required}")

        # Check if feature engineering matches requirements
        feature_steps = [step for step in self.analysis_steps if "feature" in step.action.lower()]
        if self.feature_engineering.feature_types and not feature_steps:
            issues.append("Feature engineering specified but no feature engineering steps defined")

        # Check success criteria measurability
        for criterion in self.success_criteria:
            if not criterion.metric and not criterion.threshold:
                issues.append(f"Success criterion not measurable: {criterion.criterion}")

        return issues

    def estimate_execution_time(self) -> str:
        """Estimate total execution time"""
        complexity_multipliers = {"low": 1.0, "medium": 2.0, "high": 4.0}
        base_time_per_step = 5  # minutes

        total_steps = len(self.analysis_steps)
        multiplier = complexity_multipliers[self.estimated_complexity]

        estimated_minutes = total_steps * base_time_per_step * multiplier

        if estimated_minutes < 60:
            return f"{int(estimated_minutes)} minutes"
        else:
            hours = estimated_minutes // 60
            minutes = estimated_minutes % 60
            return f"{int(hours)}h {int(minutes)}m"

    def to_execution_checklist(self) -> Dict[str, Any]:
        """Convert plan to execution checklist"""
        return {
            "objective": self.objective,
            "total_steps": len(self.analysis_steps),
            "estimated_time": self.estimate_execution_time(),
            "checklist": [
                {
                    "step": step.step,
                    "description": step.description,
                    "tools_needed": step.tools,
                    "outputs": step.outputs,
                    "completed": False
                }
                for step in self.analysis_steps
            ],
            "success_metrics": [
                {
                    "criterion": sc.criterion,
                    "target": sc.threshold,
                    "achieved": None
                }
                for sc in self.success_criteria
            ]
        }